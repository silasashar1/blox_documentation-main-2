#!/bin/python

import os
import requests
import argparse

class bcolors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKCYAN = '\033[96m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

parser = argparse.ArgumentParser()
parser.add_argument('-o', '--owner', help='Owner of the repo', default='dyte-in')
parser.add_argument('-r', '--repo', help='Repo to fetch docs from', default='web-core')
parser.add_argument('-v', '--version', help='Release version to update docs to')
parser.add_argument('-d', '--destination', help='Destination folder for reference directory', default='docs/web-core')

args = parser.parse_args()

GH_TOKEN = os.environ['GH_TOKEN']
github_api_url = 'https://api.github.com/repos'

repo = args.repo
owner = args.owner
version = args.version
destination = args.destination

github_headers = {
    'Authorization': f'token {GH_TOKEN}',
    'Accept': 'application/vnd.github.v3.raw',
}

github_latest_release_url = f'{github_api_url}/{owner}/{repo}/releases/latest'

if not version:
    version = requests.get(github_latest_release_url, headers=github_headers).json()['tag_name']

github_release_url = f'{github_api_url}/{owner}/{repo}/releases/tags/{version}'
docs_zip_url = None
docs_zip_file = '/tmp/docs.zip'
unzip_destination = '/tmp'

docs_directory = f'{unzip_destination}/docs'
reference_directory = f'./{destination}/reference'
autogenerated_separator = '<!-- Auto Generated Below -->\n'

github_release_assets = requests.get(github_release_url, headers=github_headers).json()['assets']

for asset in github_release_assets:
    if asset['name'] == 'docs.zip':
        docs_zip_url = f'{github_api_url}/{owner}/{repo}/releases/assets/{asset["id"]}'

github_download_headers = github_headers.copy()
github_download_headers.update({
    "Accept": "application/octet-stream",
})

asset_content = requests.get(docs_zip_url, headers=github_download_headers).content
open(docs_zip_file, 'wb').write(asset_content)

os.system(f'unzip -o {docs_zip_file} -d {unzip_destination}')
os.unlink(f'{docs_directory}/README.md')

def smart_replace(file_content_arr, docs_content_arr):
    separator_index = file_content_arr.index(autogenerated_separator)
    docs_separator_index = docs_content_arr.index(autogenerated_separator)

    file_content_arr = file_content_arr[separator_index:]

    print('Replacing content in references:', file)

    docs_content_arr = docs_content_arr[:docs_separator_index]
    docs_content_arr += file_content_arr

    return docs_content_arr

def header_replace(file_content_arr, docs_content_arr):
    file_header_end_index = file_content_arr.index('---\n', 1)
    docs_header_end_index = docs_content_arr.index('---\n', 1)

    file_header = file_content_arr[:file_header_end_index + 1]
    docs_content_arr = file_header + docs_content_arr[docs_header_end_index + 1:]
    return docs_content_arr

status_code = 0
for file in os.listdir(docs_directory):
    if (not os.path.exists(reference_directory)):
        os.mkdir(reference_directory)
    try:
        print('Parsing file:', file)
        file_content_arr = open(f'{docs_directory}/{file}', 'r').readlines()
        docs_content_arr = file_content_arr
        if os.path.exists(f'{reference_directory}/{file}'):
            docs_content_arr = open(f'{reference_directory}/{file}', 'r').readlines()

        if len(docs_content_arr) == 0:
            docs_content_arr = file_content_arr
        else:
            docs_content_arr = smart_replace(file_content_arr, docs_content_arr)
            docs_content_arr = header_replace(file_content_arr, docs_content_arr)

        open(f'{reference_directory}/{file}', 'w').write(''.join(docs_content_arr))

    except ValueError as e:
        print(f'{bcolors.FAIL}Failed to process file: {file}\n{e}{bcolors.ENDC}')
        status_code = 1
        pass

exit(status_code)
